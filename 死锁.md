## 死锁的基本概念

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

## 死锁产生的必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的
- 非剥夺控制：资源不能被抢占，资源只能在进程完成后自动释放
- 零散请求：进程可以逐次申请资源，而不是一次性申请所有资源。这样进程在已占有资源的情况下，又申请新的资源时而得不到满足时，不释放已有资源
- 循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

## 死锁的处理方法

### 鸵鸟政策

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

### 死锁检测与死锁恢复

不试图阻止死锁，而是检测到死锁发生的时候，采取措施进行恢复。

### 积极防御策略

指不让死锁发生，成本较高，代价较大。可以通过预防或者避免死锁的发生来实现。

## 死锁的预防

核心方法就是破坏死锁产生的必要条件

### 1. 破坏互斥条件

比如利用SPOOLing技术实现资源共享。但是这种方法不适用于所有资源，破坏互斥性比较困难

### 2. 破坏不可抢占条件

允许一个进程还未执行完的时候释放已占有的资源。

缺点是实现困难，为了恢复现场需要耗费很多时间和空间。会使被剥夺资源的进程蒙受损失。因此只适合类似CPU、存储器这样的资源

### 3. 破坏零散请求条件

要求进程在申请资源时一次性申请所有资源，而不是逐个申请。

但是会导致系统效率低，资源浪费严重。

### 4. 破坏循环等待条件

给资源统一编号，进程只能按编号顺序来请求资源

## 死锁的避免

允许死锁产生的必要条件存在，但是在系统运行过程中，通过合理的资源分配避免死锁的发生。

### 系统的状态

- 安全状态：系统可以按照某种进程执行顺序，使得每个进程都能够顺利完成
- 不安全状态：不存在一种顺序使得每个进程都能够顺利完成。不安全状态不一定发生死锁，但死锁一定是不安全状态

所以要避免死锁，就要避免进入不安全状态

### 单项资源的银行家算法

### 多项资源的银行家算法

## 死锁的检测以及解除

### 1. 每种类型一个资源的死锁检测
![每种类型一个资源的死锁检测]
    
上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

### 2. 多个资源的死锁检测

>应该不考，但是我认为是比较重要的知识点

![每种类型多个资源的死锁检测]

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P<sub>1</sub> 所请求的资源都得不到满足，只有进程 P<sub>2</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

### 死锁恢复
- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

[每种类型一个资源的死锁检测]: pictures\每种类型一个资源的死锁检测.png
[每种类型多个资源的死锁检测]: pictures\每种类型多个资源的死锁检测.png