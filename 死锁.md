## 死锁的基本概念

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

## 死锁产生的必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的
- 非剥夺控制：资源不能被抢占，资源只能在进程完成后自动释放
- 零散请求：进程可以逐次申请资源，而不是一次性申请所有资源。这样进程在已占有资源的情况下，又申请新的资源时而得不到满足时，不释放已有资源
- 循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

## 死锁的处理方法

### 鸵鸟政策

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

### 死锁检测与死锁恢复

不试图阻止死锁，而是检测到死锁发生的时候，采取措施进行恢复。

### 积极防御策略

指不让死锁发生，成本较高，代价较大。可以通过预防或者避免死锁的发生来实现。

## 死锁的预防

核心方法就是破坏死锁产生的必要条件

### 1. 破坏互斥条件

比如利用SPOOLing技术实现资源共享。但是这种方法不适用于所有资源，破坏互斥性比较困难

### 2. 破坏不可抢占条件

允许一个进程还未执行完的时候释放已占有的资源。

缺点是实现困难，为了恢复现场需要耗费很多时间和空间。会使被剥夺资源的进程蒙受损失。因此只适合类似CPU、存储器这样的资源

### 3. 破坏零散请求条件

要求进程在申请资源时一次性申请所有资源，而不是逐个申请。

但是会导致系统效率低，资源浪费严重。

### 4. 破坏循环等待条件

给资源统一编号，进程只能按编号顺序来请求资源

## 死锁的避免

允许死锁产生的必要条件存在，但是在系统运行过程中，通过合理的资源分配避免死锁的发生。

### 系统的状态

- 安全状态：系统可以按照某种进程执行顺序，使得每个进程都能够顺利完成
- 不安全状态：不存在一种顺序使得每个进程都能够顺利完成。不安全状态不一定发生死锁，但死锁一定是不安全状态

所以要避免死锁，就要避免进入不安全状态

### 单项资源的银行家算法

### 多项资源的银行家算法

## 死锁的检测以及解除

### 资源分配图的画法

1. 圆(椭圆)表示一个进程；
2. 方块表示一个资源类，其中的圆点表示该类型资源中的单
个资源；
3. 从资源指向进程的箭头表示资源被分配给了这个进程；
4. 从进程指向资源的箭头表示进程申请一个这类资源；

### 死锁的检测

1. 检查有无环路，如果没有环路，则系统一定不会发生死锁;
2. 如果有环路，则检查环路上的资源类是否都只有一个资源，如果是，则系统一定会发生死锁;
3. 如果环路上的资源类都有多个资源，查找即非阻塞又非独立的进程，消去与之有关的所有有向边
4. 如果最终能够消去所有的有向边，则系统不会发生死锁，否则系统会发生死锁

死锁定理：如果一个系统状态为死锁状态，当且仅当资源分配图是不可完全化简。也即，如果资源图中所有的进程都成为孤立结点，则系统不会死锁；否则系统状态为死锁状态

### 临时资源的死锁检测

- 临时性资源，即可消耗的资源。如信号，邮件等。特点是没有固定数量，不需要释放
- 含临时性资源的资源分配图规则：
  1. 圆表示一个进程；
  2. 方块表示一个资源类，其中的圆点表示该类型资源中的单个资源；
  3. 由进程指向资源的箭头表示该进程申请这种资源，一个箭头只表示申请一个资源；
  4. 由资源类指向进程的箭头表示该进程产生这种资源，一个箭头可表示产生一到多个资源，每个资源类至少有一个生产者进程。

### 死锁恢复
- 重新启动 ——大力出奇迹
- 撤销进程：系统撤销造成死锁的进程
   - 可以一次性撤销所有死锁进程
   - 也可以逐个撤销，分别收回资源
- 剥夺资源：保留产生死锁的进程，剥夺死锁进程占有的资源，直到解除死锁
- 进程回退：系统根据保留的历史信息，让死锁的进程开始回退直到死锁解除