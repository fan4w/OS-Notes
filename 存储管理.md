## 概述

### 存储架构体系
1. 寄存器
2. 高速缓存
3. 主存储器
4. 外存

### 程序的转化过程

![程序的转化过程]

### 逻辑地址与物理地址

- 逻辑地址（相对地址，虚拟地址）：用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址
- 物理地址（绝对地址，实地址）：内存中储存单元的地址，可直接寻址

### 链接过程

将编译后的目标模块和库函数链接成一个完整的可执行程序，形成一个完整的装入模块（可执行程序）

程序链接的三种方式：
- 静态链接
- 装入时动态链接
- 运行时动态链接

### 装入过程

当程序被装入内存时，程序的逻辑地址被转化成内存的物理地址，这一过程被称为地址重定位

#### 绝对装入(absolute loading)

程序的装载地址（物理地址）是在编译链接的时候直接生成的。程序的逻辑地址与物理地址一致

#### 可重定位装入(relocatable loading)

- 静态重定位：允许程序装入内存中的任意位置，因此地址的重定位是在装入时完成的，且只进行一次，在程序的执行期间地址将不再发生变化，因此也称为静态重定位
- 运行时重定位/动态重定位：程序在装入内存时，不修改程序的逻辑地址值，程序在访问物理内存之前，再实时地将逻辑地址转换成物理地址

## 连续分配方式

要求程序必须被连续的存储在一段内存区域之内

- 单一连续分区管理：内存一次允许装入一个用户程序，程序独占整个用户区
- 固定分区管理：先分区再分配
- 动态分区管理（可变分区）：预先不划分内存，当作业需要装载时系统从内存中分出一块，其大小等于该作业的大小，然后将剩下的部分再作为空白块给下一次分配使用

### 分区分配算法

|     算法     |                             思想                             |       空闲分区       |      优点      |                         缺点                         |
| :----------: | :----------------------------------------------------------: | :------------------: | :------------: | :--------------------------------------------------: |
| 最先适应算法 |             从前往后找到第一个满足要求的空闲分区             |     地址递增排序     |   简单，快速   |               产生大量无法利用的小碎片               |
| 邻近适应算法 | 从上次分配的空闲分区开始找，直到找到第一个满足要求的空闲分区 | 地址递增排序（循环） |   简单，快速   |               产生大量无法利用的小碎片               |
| 最佳适应算法 |           从所有满足要求的空闲分区中找到最小的一个           |     容量递增排序     | 大分区得以保留 |   产生小碎片。开销大，回收分区要重新对空闲分区排队   |
| 最坏适应算法 |           从所有满足要求的空闲分区中找到最大的一个           |     容量递减排序     |   减少小碎片   | 大分区不能保留。开销大，回收分区要重新对空闲分区排队 |

### 解决碎片问题的策略——紧凑

移动所有被分配的分区，使之成为一个连续区域，而留下一个较大的空白区

### 连续分配方式的局限

作业存储时必须连续存放。这样当一个作业大于当前最大的空闲分区容量时，即使主存中有空闲区域也不能够利用，从而降低了存储空间利用率

## 非连续分配方式

将程序分为若干块，分别放在不同的空闲区中，从而使得存储空间的利用率得到提升。

### 页式存储管理技术

把作业的虚拟地址空间划分为若干个长度相等的页(pages)，也可以成为虚页。主存页划分为若干个与虚页长度相等的页框(page frame)，也称为页面或实页

#### 页面变换表(Page Table)

也叫页表，是一种特殊的数据结构，用于记录虚页与实页的对应关系

| 页号  | 页内地址 |
| :---: | :------: |

#### 快表(TLB, Translation Lookaside Buffer)

把一部分访问频率较高的页表放在Cache中

#### 优缺点

优点：
1. 程序不用连续存放
2. 没有外碎片

缺点：
1. 程序要一次全部装入内存
2. 页表体积庞大，维护麻烦
3. 依然存在内碎片

### 段式存储管理技术

根据程序的模块结构，把作业换成多个段。每段有一个段名，段号从0开始，每一段内也从0连续编址(偏移W)，通常分为主程序段，子程序段，库函数段，数据段等等。同时在物理内存中，也分成一些和这些块一样大的块。作业必须一次性全部装入

- 要访问的逻辑地址由段号和逻辑偏移量组成，每个段都从0开始编址。
- 分段共享：某个段可以单独拿出来共享
- 分段保护：对不同的段实现不同种类的保护
- 动态链接：动态链接要求以段作为管理的单位

#### 优点
1. 程序不需要连续存放
2. 没有内碎片
3. 程序尺寸几乎不受限制
4. 便于实现共享
5. 段表比页表小

#### 缺点
1. 有外碎片
2. 程序装入时需要全部装入

### 段页式存储管理技术

用户程序按段划分，物理内存按页划分，即以页为单位进行分配

| 段号S | 页号P | 页内地址W |
| :---: | :---: | :-------: |

- 段表记录了每一页的页表的起始地址和页表长度
- 页表记录了每一段所对应的逻辑页号与内存块号的对应关系，每一段有一个页表

通过三次访问取指令或数据
1. 访问内存中的段表，获得页表地址
2. 访问内存中的页表，获得该页所在的物理块号
3. 真正根据所得的物理地址取出指令或者数据

## 内存扩充技术

借助大容量的辅存在逻辑上扩充内存容量，使得程序能够在较大的地址空间中运行

### 覆盖技术(Overlay)   

将程序的必要部分的代码和数据常驻内存；将可选部分在其它模块中实现，平时放在辅存中，需要时再调入内存。不存在调用关系的内存不需要同时装入内存，从而可以相互覆盖

要求程序员编写调用关系明确的程序，对程序员要求高

### 交换技术(Swapping)

系统把内存中某些进程暂移到外存上，从而把内存空间腾出来，以便为即将调入的进程提供空间。这种技术是进程在内存和外存之间调度的中级调度。交换过程发生在作业之间。

交换区(Swap Area)：用于存放被交换出的进程的空间，包含连续的磁道。操作系统可以用底层的磁盘读写操作对其高效访问

- 优点：增加并发执行的程序数目；对程序员透明
- 缺点：增加处理机开销；交换信息量大，程序换入时需要重定位

### 虚拟存储技术(Virtual Memory)

#### 局部性原理

程序执行的一个较短时间内，所执行的指令地址和指令的操作数地址，分别局限于一定区域，可以表现为：
- 时间局限性：一个指令的访问和下次访问，一个数据的访问和下次访问都集中在一个较短时间内
- 空间局部性：当前指令和邻近的指令，当前数据和邻近的数据都集中在一个较小的区域内

#### 虚拟存储的基本原理

- 在程序装入时不必将其全部读入内存，而只需要将当前需要执行的部分页或段读入内存就可以开始执行
- 在程序执行过程中，如果需要用到的指令或者数据不在内存中，则通知操作系统把需要的页或段调入内存，继续执行
- 操作系统将内存中暂时不使用的页或段调出保存在外存上，从而腾出空间存放将要装入的程序以及将要调入的页或段―具有请求调入和置换功能，只需程序的一部分在内存就可执行
  
#### 虚拟存储的实现

- 虚拟页式（请求分页）
- 虚拟段式（请求分段）
- 虚拟段页式（请求分段页）

## 虚拟页式存储技术

逻辑地址空间映射到虚拟地址空间

### 页面淘汰算法

- 先进先出算法(FIFO)：选择最先进入内存的页面淘汰
- 最近最少使用算法(LRU)：选择最近最久未使用的页面淘汰

[程序的转化过程]: pictures/程序的转化过程.png